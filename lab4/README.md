# Лабораторная работа №4. Вариант 17

## Грамматика

S → T a S S a T S₁.v == S₂.v, S₀.v := min(T₁.v, T₂.v)  
T → T a T T₀.v := T₁.v + T₂.v  
T → b b T.v := 1  
S → aba S.v := 1  
S → b b S S₀.v := 0  

## 1. Исходная грамматика эквивалентна следующей

S → b b S S₀.v := 0  
S → aba S.v := 1  

S → (bba)ⁿ S S (abb)ᵐ S₁.v == S₂.v, S₀.v := min(n, m), n, m > 0  

Заменим для удобства bba = A, abb = B, aba = C и рассмотрим слово  

w = A A^(p/6) C C B^(p/6+1) A^(p/6) C C B^(p/6+1) B 


1. При отрицательной накачке любого блока A^(p/6) нарушается условие S1.v == S2.v
2. При отрицательной накачке любого блока B^(p/6 + 1) он становится минимумом, и, так как, для предотвращения нарушения структуры, нам придется убрать хотя бы 6 символов, то снова нарушается условие S1.v == S2.v
3. Если мы будем одновременно качать первые A^(p/6) и B^(p/6 + 1) или вторые A^(p/6) и B^(p/6 + 1) (сразу качать больше блоков не можем из-за ограничения по длине <= p (длина A^(p/6) и B^(p/6 + 1) в символах p + 3)), то вторые или первые соответственно накачиваться не будут, и снова нарушается условие S1.v == S2.v.
4. Аналогично для одновременной накачки первого B^(p/6 + 1) и второго A^(p/6) также нарушается условие выше.
5. При попытке накачивать вне блоков полностью нарушается структура всего слова.

Исходя из этого язык - не КС.

## 2. Наивный парсер

Наивный парсер построен рекурсивно, перебирая в лоб все возможные варианты разбора слова.  

## 3. Оптимизированный парсер

Оптимизированный парсер построен перебором циклами и использует тот факт, что aba в слове – это всегда конец какого-то S. Его сложность – O(n⁶), где n – длина слова.  

## 4. Графики скорости работы парсеров

- на батче слов не из языка:  
  ![plot1](plot1.png)  

- на батче слов из языка:  
  ![plot2](plot2.png)  
